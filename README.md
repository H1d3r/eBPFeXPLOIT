# eBPF-exploit

学习eBPF后一直想拿ebpf写一些东西，有考虑过写类似KubevArmor这样的工具，但是感觉这有些太大了，还是一步步来从小一点的工具出发。

之前逛github的时候发现了veo师傅写的ebpf内存马：[veo/ebpf_shell: ebpf WebShell/内核马，一种新型内核马/WebShell技术](https://github.com/veo/ebpf_shell) ，觉得这个项目很适合作为入门学习的项目，而且感觉通过hook别的execve来执行命令局限性太大了，就决定自己写一个相关的工具。

在写的过程中也参考了一些其他的项目，都放在了References中了。



目前实现的功能有：

- 隐藏自己的PID和指定的其他Pid，考虑到处理的方便至多隐藏5个pid。
- ebpf内存马。



后续实现计划：

- ebpf程序隐藏。
- 间接执行命令，即hook execve来执行。
- 对程序整体结构进行重构，一开始单纯的为了实现功能导致代码写的非常混乱。
- 对低版本Linux的兼容。写代码的时候使用了很多新功能，导致了低版本Linux内核不兼容。
- etcd...

## Hide Pid

隐藏至多4个目标PID和自己的PID，一共5个pid。默认隐藏自己

```bash
go generate &&go build -o main &&./main -pid 263959,269942


echo $$
263959
ps aux | grep -i "263959"
root      277863  0.0  0.0   3440  1920 pts/2    S+   13:51   0:00 grep --color=auto -i 263959

```



## ebpf-MemoryShell

能够实现基本的内存马功能，但是还是有一系列的问题：

- 暂时没有处理分片传输。
- 我本地的虚拟机Linux有问题，一直配不好tc只接收egress流量，导致了tc是接收的egress和ingress全流量，性能相对来说会下降。
- 执行命令是用户态里执行命令，
- 命令执行必须放到get的最后一个参数中，因为不这样的话ebpf内核态处理会很麻烦导致过不去verify。
- 必须原始的http响应字节数比命令执行结果的字节数多才能完全回显，尝试过扩充http的响应包。可以使用`bpf_skb_change_tail`扩充，但是同样还需要修改http响应头中的`Content-Length`的值，非常的复杂导致过不去verify。



在处理网络数据包的性能上，XDP优于TC优于hook syscall，因此XDP一定是第一选择，但是xdp只能接收ingress的流量，而tc可以收到egress的流量，因此让二者分开进行处理两侧。

![TCP/IP  数据包报文格式（IP包、TCP报头、UDP报头）_数据包_02](README.assets/resize,m_fixed,w_1184)



xdp将接收到的命令发到用户态并执行后，用户态再将执行的结果发给TC，将结果写到http的响应中，而且如果执行结果想完全回显，必须找一个有比结果字节数多的http响应，一般还是比较好找的。

虽然提供了`dexec`这个选项，实际上`dexec=0`的功能还没有实现。

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")


./main -ifname lo -dexec 1
```

![image-20240105165324387](README.assets/image-20240105165324387.png)



## Hide ebpf program

TODO

## Other function?

目前一切都不考虑将程序和Map pin到fs中，只为了提供方便的功能，等到整体功能实现的差不多之后可能会考虑。



## How to Use

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")
```

隐藏其他Pid，默认会隐藏程序自身的pid：

```bash
./main -pid 263959,269942
```

内存马：

```bash
./main -ifname lo -dexec 1
```

`ifname`指定网络接口，`dexec`设置为1即可。

目前的程序只是简单的提供功能，因此启动程序后执行`ctrl+c`就可以停止程序。

如果程序在tc上遇到的问题导致没有清除，可以手动清除：

```bash
tc qdisc del dev lo clsact
```

自行将lo换成自己的网络接口即可。





程序中用到了`BPF_MAP_TYPE_RINGBUF`等比较新的功能，我没有太细查最低的版本要求，问了一下gpt大概是差不多Kernel 5.8以上。

所以5.8及其以上版本的Linux内核理论上是能跑的通的。

## References

[[译]使用os/exec执行命令](https://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/)

[bpf-developer-tutorial/src/23-http/README.md at main · eunomia-bpf/bpf-developer-tutorial](https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/23-http/README.md)

[使用cilium/ebpf编译并加载TC BPF代码](https://d0u9.io/use-cilium-ebpf-to-compile-and-load-tc-bpf-code/)

[Gui774ume/ebpfkit: ebpfkit is a rootkit powered by eBPF](https://github.com/Gui774ume/ebpfkit)

[pathtofile/bad-bpf: A collection of eBPF programs demonstrating bad behavior, presented at DEF CON 29](https://github.com/pathtofile/bad-bpf)

[Emulating Bad Networks](https://samwho.dev/blog/emulating-bad-networks/)

[Routing Family Netlink Library (libnl-route)](https://www.infradead.org/~tgr/libnl/doc/route.html#route_tc)

[Attaching EBPF program returns no such file or directory · Issue #32 · florianl/go-tc](https://github.com/florianl/go-tc/issues/32)

[tc package - github.com/florianl/go-tc - Go Packages](https://pkg.go.dev/github.com/florianl/go-tc#section-readme)

[绿色记忆:eBPF学习笔记](https://blog.gmem.cc/ebpf)
