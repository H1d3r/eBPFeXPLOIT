# eBPF-exploit

学习eBPF后一直想拿ebpf写一些东西，有考虑过写类似KubevArmor这样的工具，但是感觉这有些太大了，还是一步步来从小一点的工具出发。

之前逛github的时候发现了veo师傅写的ebpf内存马：[veo/ebpf_shell: ebpf WebShell/内核马，一种新型内核马/WebShell技术](https://github.com/veo/ebpf_shell) ，觉得这个项目很适合作为入门学习的项目，而且感觉通过hook别的execve来执行命令局限性太大了，就决定自己写一个相关的工具。

在写的过程中也参考了一些其他的项目，都放在了References中了。



目前实现的功能有：

- 隐藏自己的PID和指定的其他Pid，考虑到处理的方便至多隐藏5个pid。
- ebpf内存马。



后续实现计划：

- ebpf程序隐藏。
- 间接执行命令，即hook execve来执行。
- 对程序整体结构进行重构，一开始单纯的为了实现功能导致代码写的非常混乱。
- 对低版本Linux的兼容。写代码的时候使用了很多新功能，导致了低版本Linux内核不兼容。
- etcd...

## Hide Pid

隐藏至多4个目标PID和自己的PID，一共5个pid。默认隐藏自己

```bash
go generate &&go build -o main &&./main -pid 263959,269942


echo $$
263959
ps aux | grep -i "263959"
root      277863  0.0  0.0   3440  1920 pts/2    S+   13:51   0:00 grep --color=auto -i 263959

```



隐藏Pid的原理就在于`getdents64`系统调用。在 Linux 中，`getdents64` 系统调用可以读取目录下的文件信息，ps等命令的底层都是通过`getdents64`获取`/proc/`文件夹下面文件的信息来获取进程相关信息。

`ctx`的第二个参数是`linux_dirent64 *dirp`，它的结构如下：

```c
 struct linux_dirent64 {
     u64        d_ino;    /* 64-bit inode number */
     u64        d_off;    /* 64-bit offset to next structure */
     unsigned short d_reclen; /* Size of this dirent */
     unsigned char  d_type;   /* File type */
     char           d_name[]; /* Filename (null-terminated) */ };
```

它实际上代表了`getdents64`将要访问的目录中的条目。前两个字段意义不大，第三个指的是当前这个`linux_dirent64`的长度，第五个`d_name`指的是当前目标的文件名，例如`pid`是200的话，即`/proc/200`，那么`d_name`就是200。

因此只要hook这个进程，将目标Pid的`linux_dirent64`的前一个`linux_dirent64`的`d_reclen`修改为`d_reclen_previous + d_reclen`，这样就可以跳过目标Pid的文件，实现了Pid的隐藏。

但是因为中间的逻辑比较复杂，如果要隐藏的Pid过多的话verifyier会炸，因此算上程序本身，至多隐藏5个。



## ebpf-MemoryShell

能够实现基本的内存马功能，但是还是有一系列的问题：

- 暂时没有处理分片传输。
- 我本地的虚拟机Linux有问题，一直配不好tc只接收egress流量，导致了tc是接收的egress和ingress全流量，性能相对来说会下降。
- 执行命令是用户态里执行命令，
- 命令执行必须放到get的最后一个参数中，因为不这样的话ebpf内核态处理会很麻烦导致过不去verify。
- 必须原始的http响应字节数比命令执行结果的字节数多才能完全回显，尝试过扩充http的响应包。可以使用`bpf_skb_change_tail`扩充，但是同样还需要修改http响应头中的`Content-Length`的值，非常的复杂导致过不去verify。



在处理网络数据包的性能上，XDP优于TC优于hook syscall，因此XDP一定是第一选择，但是xdp只能接收ingress的流量，而tc可以收到egress的流量，因此让二者分开进行处理两侧。

![TCP/IP  数据包报文格式（IP包、TCP报头、UDP报头）_数据包_02](README.assets/resize,m_fixed,w_1184)



xdp将接收到的命令发到用户态并执行后，用户态再将执行的结果发给TC，将结果写到http的响应中，而且如果执行结果想完全回显，必须找一个有比结果字节数多的http响应，一般还是比较好找的。

虽然提供了`dexec`这个选项，实际上`dexec=0`的功能还没有实现。

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")


./main -ifname lo -dexec 1
```

![image-20240105165324387](README.assets/image-20240105165324387.png)



## Prevent Kill

虽然隐藏了Pid，假如运维还是以某种方式知道了我们程序的pid的话，需要阻止Kill命令杀死我们的进程。



首先hook `lsm/task_kill`，遇到要保护的pid的时候`return -EPERM`，阻止后续的执行。

同时hook `kretprobe/sys_kill`，当syscall返回的时候修改返回值为`-ESRCH`，就可以伪装该进程不存在：

```bash
go build -o main &&./main
2024/01/06 19:19:40 current pid:398235
2024/01/06 19:19:40 Waiting for events..


kill -9 398235
bash: kill: (398235) - No such process

```

考虑过用kprobe或者tp，但是没有很好的办法在enter的时候阻止后续的处理，因此只能用lsm，但感觉这似乎不是一个最好办法。

## Hide ebpf program



TODO

## Other function?

目前一切都不考虑将程序和Map pin到fs中，只为了提供方便的功能，等到整体功能实现的差不多之后可能会考虑。



## How to Use

```bash
 ./main --help
Usage of ./main:
  -dexec string
        directly exec or not (default "-1")
  -ifname string
        interface xdp and tc will attach
  -pid string
        pid to hide (default "-1")
```

隐藏其他Pid，默认会隐藏程序自身的pid：

```bash
./main -pid 263959,269942
```

内存马：

```bash
./main -ifname lo -dexec 1
```

`ifname`指定网络接口，`dexec`设置为1即可。

目前的程序只是简单的提供功能，因此启动程序后执行`ctrl+c`就可以停止程序。

如果程序在tc上遇到的问题导致没有清除，可以手动清除：

```bash
tc qdisc del dev lo clsact
```

自行将lo换成自己的网络接口即可。





程序中用到了`BPF_MAP_TYPE_RINGBUF`等比较新的功能，我没有太细查最低的版本要求，问了一下gpt大概是差不多Kernel 5.8以上。

所以5.8及其以上版本的Linux内核理论上是能跑的通的。**此外程序需要以root权限运行。**

可执行程序是用go交叉编译出来的，理论上别的架构也能执行？这是我的内核版本：

```bash
uname -a
Linux ubuntu-linux-22-04-02-desktop 6.5.13-060513-generic #202311281736 SMP PREEMPT_DYNAMIC Tue Nov 28 18:10:14 UTC 2023 aarch64 aarch64 aarch64 GNU/Linux
```

源码暂时不放出来因为还有别的功能没有实现，而且代码还没有重构，都实现完毕会放出源码。

## References

[[译]使用os/exec执行命令](https://colobu.com/2017/06/19/advanced-command-execution-in-Go-with-os-exec/)

[bpf-developer-tutorial/src/23-http/README.md at main · eunomia-bpf/bpf-developer-tutorial](https://github.com/eunomia-bpf/bpf-developer-tutorial/blob/main/src/23-http/README.md)

[使用cilium/ebpf编译并加载TC BPF代码](https://d0u9.io/use-cilium-ebpf-to-compile-and-load-tc-bpf-code/)

[Gui774ume/ebpfkit: ebpfkit is a rootkit powered by eBPF](https://github.com/Gui774ume/ebpfkit)

[pathtofile/bad-bpf: A collection of eBPF programs demonstrating bad behavior, presented at DEF CON 29](https://github.com/pathtofile/bad-bpf)

[Emulating Bad Networks](https://samwho.dev/blog/emulating-bad-networks/)

[Routing Family Netlink Library (libnl-route)](https://www.infradead.org/~tgr/libnl/doc/route.html#route_tc)

[Attaching EBPF program returns no such file or directory · Issue #32 · florianl/go-tc](https://github.com/florianl/go-tc/issues/32)

[tc package - github.com/florianl/go-tc - Go Packages](https://pkg.go.dev/github.com/florianl/go-tc#section-readme)

[绿色记忆:eBPF学习笔记](https://blog.gmem.cc/ebpf)
